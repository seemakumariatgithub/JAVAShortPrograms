üè≠ FACTORY DESIGN PATTERN ‚Äî THE COMPLETE GUIDE

  The Factory Pattern belongs to the Creational Design Patterns category.
  It helps in creating objects without exposing the creation logic to the client.
===============================================================================
‚úÖ 1. What Problem Does Factory Pattern Solve?

    When your code does this:
    
        if(type.equals("CAR")) return new Car();
        else if(type.equals("BIKE")) return new Bike();
        else if(type.equals("BUS")) return new Bus();
  
    This introduces problems:
        ‚ùå Many if-else or switch statements
        ‚ùå Client needs to know concrete classes
        ‚ùå Hard to extend (adding new type ‚Üí modify existing code ‚Üí violates OCP)
    
    The Factory Pattern solves these by:
          Encapsulating object creation in one place
          Returning a common interface type

  ============================================================================================================
  üéØ 2. Where Do We Use It? (Real Examples)
           - Spring uses Factory pattern heavily (BeanFactory)
           - JDBC uses factories: DriverManager.getConnection()
           - Logging frameworks: LoggerFactory.getLogger(...)
           - Executors: Executors.newFixedThreadPool()
           - WebClient builder: WebClient.builder()

  =============================================================================================================
  üè≠ 3. Types of Factory Patterns
          There are 3 commonly used variants:
          
        | Pattern              | Purpose                                            |
        | -------------------- | -------------------------------------------------- |
        | Simple Factory       | Central place to create objects for multiple types |
        | Factory Method       | Subclasses decide which object to create           |
        | Abstract Factory     | Creates families of related objects                |
=================================================================================================================
üß± 3.1      SIMPLE FACTORY (most common)
        üìå Structure

          Client ‚Üí Factory ‚Üí Product Interface ‚Üí Concrete Products
          
================================================================================================================
üü¶ Example: Notification Factory
      1Ô∏è‚É£ Product interface:-
        
              public interface Notification {
                  void send(String message);
              }

    2Ô∏è‚É£ Concrete implementations:-
                
                public class EmailNotification implements Notification {
                    public void send(String message) {
                        System.out.println("Email: " + message);
                    }
                }

                public class SMSNotification implements Notification {
                    public void send(String message) {
                        System.out.println("SMS: " + message);
                    }
                }
                
                public class PushNotification implements Notification {
                    public void send(String message) {
                        System.out.println("Push: " + message);
                    }
                }
                
        3Ô∏è‚É£ Factory class:-
        
                  public class NotificationFactory {
                  
                      public static Notification getNotification(String type) {
                          return switch (type.toUpperCase()) {
                              case "EMAIL" -> new EmailNotification();
                              case "SMS" -> new SMSNotification();
                              case "PUSH" -> new PushNotification();
                              default -> throw new IllegalArgumentException("Unknown type");
                          };
                      }
                  }

          4Ô∏è‚É£ Client:-
            
          public class ClientClass {
              public static void main(String[] args) {
                  Notification n = NotificationFactory.getNotification("email");
                  n.send("Hello World!");
              }
          }
      ============================================
      üéØ Advantages:
                   ‚úî Cleaner code, no complex if-else
                   ‚úî Encapsulates object creation
                   ‚úî Single responsibility
                   ‚úî Easy to extend ‚Üí add new classes without changing client
                    
      ‚ö†Ô∏è Disadvantages:
                   ‚ùå Factory grows large if too many object types
                   ‚ùå Still violates OCP if modified frequently (Factory Method fixes this)
=============================================================================================================================================
üèó 3.2 FACTORY METHOD PATTERN
                Here the factory itself is abstract, and subclasses decide what to create.
        
        üìå Structure:
                  Creator (abstract)
                       ‚Üë
                  Concrete Creators
                       ‚Üì
                  Products
              
  ============================================================================================
              Example: Document creator (Word / PDF)
              1Ô∏è‚É£ Product
                        public interface Document {
                            void open();
                        }
              
              2Ô∏è‚É£ Concrete Products
                          public class WordDocument implements Document {
                              public void open() {
                                  System.out.println("Opening Word...");
                              }
                          }
              
                          public class PdfDocument implements Document {
                              public void open() {
                                  System.out.println("Opening PDF...");
                              }
                          }
              
              3Ô∏è‚É£ Creator (abstract)
                          public abstract class DocumentCreator {
                              public abstract Document createDocument();
                          
                              public void openDocument() {
                                  Document doc = createDocument();
                                  doc.open();
                              }
                          }
              
              4Ô∏è‚É£ Concrete Creators
                          public class WordDocumentCreator extends DocumentCreator {
                              public Document createDocument() {
                                  return new WordDocument();
                              }
                          }
                          
                          public class PdfDocumentCreator extends DocumentCreator {
                              public Document createDocument() {
                                  return new PdfDocument();
                              }
                          }
                          
              5Ô∏è‚É£ Client
                          DocumentCreator creator = new PdfDocumentCreator();
                          creator.openDocument();
============================================================================================================
üåê 6. ABSTRACT FACTORY PATTERN

















          
