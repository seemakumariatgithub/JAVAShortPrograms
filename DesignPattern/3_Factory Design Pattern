ğŸ­ FACTORY DESIGN PATTERN â€” THE COMPLETE GUIDE

  The Factory Pattern belongs to the Creational Design Patterns category.
  It helps in creating objects without exposing the creation logic to the client.
===============================================================================
âœ… 1. What Problem Does Factory Pattern Solve?

    When your code does this:
    
        if(type.equals("CAR")) return new Car();
        else if(type.equals("BIKE")) return new Bike();
        else if(type.equals("BUS")) return new Bus();
  
    This introduces problems:
        âŒ Many if-else or switch statements
        âŒ Client needs to know concrete classes
        âŒ Hard to extend (adding new type â†’ modify existing code â†’ violates OCP)
    
    The Factory Pattern solves these by:
          Encapsulating object creation in one place
          Returning a common interface type

  ============================================================================================================
  ğŸ¯ 2. Where Do We Use It? (Real Examples)
           - Spring uses Factory pattern heavily (BeanFactory)
           - JDBC uses factories: DriverManager.getConnection()
           - Logging frameworks: LoggerFactory.getLogger(...)
           - Executors: Executors.newFixedThreadPool()
           - WebClient builder: WebClient.builder()

  =============================================================================================================
  ğŸ­ 3. Types of Factory Patterns
          There are 3 commonly used variants:
          
        | Pattern              | Purpose                                            |
        | -------------------- | -------------------------------------------------- |
        | Simple Factory       | Central place to create objects for multiple types |
        | Factory Method       | Subclasses decide which object to create           |
        | Abstract Factory     | Creates families of related objects                |
=================================================================================================================
ğŸ§± 3.1      SIMPLE FACTORY (most common)
        ğŸ“Œ Structure

          Client â†’ Factory â†’ Product Interface â†’ Concrete Products
          
================================================================================================================
ğŸŸ¦ Example: Notification Factory
      1ï¸âƒ£ Product interface:-
        
              public interface Notification {
                  void send(String message);
              }

    2ï¸âƒ£ Concrete implementations:-
                
                public class EmailNotification implements Notification {
                    public void send(String message) {
                        System.out.println("Email: " + message);
                    }
                }

                public class SMSNotification implements Notification {
                    public void send(String message) {
                        System.out.println("SMS: " + message);
                    }
                }
                
                public class PushNotification implements Notification {
                    public void send(String message) {
                        System.out.println("Push: " + message);
                    }
                }
                
        3ï¸âƒ£ Factory class:-
        
                  public class NotificationFactory {
                  
                      public static Notification getNotification(String type) {
                          return switch (type.toUpperCase()) {
                              case "EMAIL" -> new EmailNotification();
                              case "SMS" -> new SMSNotification();
                              case "PUSH" -> new PushNotification();
                              default -> throw new IllegalArgumentException("Unknown type");
                          };
                      }
                  }

          4ï¸âƒ£ Client:-
            
          public class ClientClass {
              public static void main(String[] args) {
                  Notification n = NotificationFactory.getNotification("email");
                  n.send("Hello World!");
              }
          }
      ============================================
      ğŸ¯ Advantages:
                   âœ” Cleaner code, no complex if-else
                   âœ” Encapsulates object creation
                   âœ” Single responsibility
                   âœ” Easy to extend â†’ add new classes without changing client
                    
      âš ï¸ Disadvantages:
                   âŒ Factory grows large if too many object types
                   âŒ Still violates OCP if modified frequently (Factory Method fixes this)
=============================================================================================================================================
ğŸ— 3.2 FACTORY METHOD PATTERN
                Here the factory itself is abstract, and subclasses decide what to create.
        
        ğŸ“Œ Structure:
                  Creator (abstract)
                       â†‘
                  Concrete Creators
                       â†“
                  Products

















          
