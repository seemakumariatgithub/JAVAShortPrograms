üéØ 11. One-Line Definition:

              A virtual thread is a lightweight, JVM-managed thread
              that makes blocking operations cheap and lets Java scale to millions of concurrent tasks 
                without changing the traditional thread-based programming model.


  - Virtual Threads in Java (introduced in Java 21 ‚Äì Project Loom)

=========================================

Virtual Thread in short

      Managed by JVM, not by OS.
      Extremely lightweight (thousands ‚Üí millions).
      Designed for high-concurrency workloads.
      Blocking is cheap ‚Äî JVM simply unmounts the thread.
      Created fast and garbage collected quickly.

==========================================

‚úÖ 3. How Virtual Threads Work Internally
              It uses:
                  Carrier threads (few OS threads)
                  Scheduler (ForkJoinPool-like)
                  Continuation-based suspension
              
              Process:
                  A virtual thread runs on a carrier OS thread.
                  When it blocks (e.g., DB call) ‚Üí JVM "unmounts" it.
                  Carrier thread becomes free to run another virtual thread.
                  When blocking ends ‚Üí JVM "remounts" it on any carrier.
              
              - This is why blocking is cheap.
===========================================

There are 3 ways to create virtual threads:

    1. Option 1: New factory (most common)
            Thread.startVirtualThread( () -> {})

    2. Option 2: Use Thread.ofVirtual()
            Thread.ofVirtual().start( ()->{} )

    3. Option 3: ExecutorService with virtual threads

            try( var executor= Executors.newVirtualThreadPerTaskExecutor() ) {
                executor.submit( () -> work() );
        }
===========================================
‚úÖ 5. When Should You Use Virtual Threads?

          Best for:
            High-concurrency servers
            REST APIs
            JDBC database calls
            File I/O
            Message-driven systems
            Thread-per-request architecture
            
          Not useful for:
              CPU-heavy tasks (use platform threads instead)
              Very tight loops

==========================================
‚úÖ 8. Example: Handling 1 million tasks
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i < 1_000_000; i++) {
        executor.submit(() -> {
            Thread.sleep(1000);
            return null;
        });
    }
}


This is completely impossible using platform threads.

============================================
‚úÖ 9. How It Helps in Spring Boot
            - Spring Boot 3.2+ supports virtual threads.

          Configuration:
          
            @Bean
            public Executor taskExecutor() {
                return Executors.newVirtualThreadPerTaskExecutor();
            }

        - Your REST APIs automatically become highly scalable.

===========================================
‚úÖ Where is a Virtual Thread stored?
    1Ô∏è‚É£ The virtual thread object itself
    
    ‚úî Stored in the Java Heap
        (because it's a normal java.lang.Thread object)
     Just like any other Java object.

===========================================
2Ô∏è‚É£ What about the stack?
      For platform threads:
            They have a fixed-size stack (typically 1‚Äì2 MB)
            Allocated in native memory (not heap)

    For virtual threads:
        They do NOT have a fixed native stack
        Instead, their stack is continuation-based, stored as:
        Small chunks ("stack frames") in the Java Heap
        Grown and shrunk dynamically
        Garbage-collected like normal objects

  Therefore:
    ‚úî Virtual thread stack resides in the heap as objects
    ‚ùå Not in the native stack of OS threads
    ‚ùå Not pre-allocated 1‚Äì2 MB


===========================================
B. Virtual Thread Executor (NEW way)
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

for (int i = 0; i < 1000; i++) {
    executor.submit(() -> {
        Thread.sleep(1000);  // blocking is cheap
        return null;
    });
}


‚úî Creates 1000 virtual threads immediately
‚úî Each task suspends without blocking carrier threads
‚úî Huge scalability (up to millions)


